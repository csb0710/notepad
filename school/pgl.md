명령형 언어 : 폰 노이만 구조에 기반한 언어
배정문 : CPU와 기억 장소 간의 데이터 이동 연산 담당
반복문 : 폰 노이만 구조에서 반복 연산을 구현함

인출 실행 사이클 : 기계 코드 프로그램을 실행하는 과정
프로그램 계수기 : 다음에 실행될 명령어의 주소를 저장하는 레지스터

컴퓨터의 두 가지 구성 요소 : 내부 기억 장소, 프로세서
내부 기억 장소 : 프로그램과  데이터를 저장하는 장소
프로세서 : 기계 명령어들의 집합을 구현하는 회로들의 모임

컴파일러 구현 : 프로그램을 컴퓨터에서 직접 실행될 수 있는 기계어로 번역하는 구현
   장점 : 일단 번역 과정이 완료되면, 매우 빠름
링킹 연산 : 시스템 프로그램의 시작 주소를 사용자 프로그램 상의 시스템 프로그램 호출 위치에 저장

순수 인터프리터 구현 : 어떠한 번역 과정 없이, 인터프리터라 불리는 또 다른 프로그램에 의해 해석됨
   장점 : 많은 원시 수준 디버깅 연산을 쉽게 구현할 수 있음   예) 배열 첨자가 범위를 벗어난 경우
   단점 : 실행 시간이 컴파일된 시스템보다 10배 내지 100배 정도 느림 -> 고급 언어 문장을 해석해야 하기 때문
            원시 프로그램 외에도 심볼 테이블이 해석 과정에 존재해야 하기 때문에 더 많은 기억 공간을 요구

혼합형 구현 : 컴파일러 구현과 순수 인터프린터 구현 간의 절충된 구현 -> 용이한 해석이 가능하도록 중간 언어로 번역

-----------------------------------
변수 : 컴퓨터 메모리 셀이나 셀들의 모임에 대한 추상화

이름 : 프로그램에서 어떤 개체를 식별하기 위하여 사용되는 문자열
주소 : 변수와 연관된 기계 메모리 주소

별칭 : 두 개 이상의 변수 이름이 동일한 메모리 위치를 접근하는데 사용할 수 있는 변수

타입 : 변수가 저장할 수 있는 값들의 범위 + 그 타입의 값들에 대해서 정의되는 연산들의 집합

값 : 변수에 연관된 메모리 셀이나 셀들의 내용

바인딩 : 속성과 엔터티 사이의 연관

정적 바인딩 : 바인딩이 실행 시간이 시작되기 전에 일어나고 프로그램 실행 전체에 걸쳐서 변하지 않는 상태
동적 바인딩 : 바인딩이 실행 시간 중에 일어나거나 프로그램 실행 과정에서 변경될 수 있는 바인딩

정적 타입 바인딩 : 변수에 바인딩된 타입은 프로그램 단위의 존속기간 동안 고정됨
동적 타입 바인딩 : 변수의 타입이 선언문으로 명세되지 않으며, 그 이름의 철자로부터도 결정될 수 없음 -> 변수에 어떤 값이 할당 될 때 타입 바인딩
   장점 : 임의의 수치 타입의 데이터를 다룰 수 있는 포괄적 프로그램 작성이 가능하기 때문에 유연성을 제공
   단점 : 타이핑 오류로 배정문을 잘못 입력 한 경우에도 오류를 발견하지 못하는 등 프로그램을 덜 신뢰적으로 만듬
           실행 시간에 타입 검사가 수행되어야하기 때문에 실행 속도가 느려짐
           모든 변수가 현재의 타입을 유지하고 관리하기 위한 추가 메모리 비용 발생

바인딩을 이해하는 것이 중요한 이유 : 명령형 프로그래밍 언어는 변수들에 대한 기억 공간 바인딩의 설계에 의해 많은 것이 결정되기 때문에

할당 : 변수에 바인딩되는 메모리 셀을 가용 메모리의 풀로부터 가져오는 과정
회수 : 변수로부터 바인딩이 해제된 메모리 셀을 다시 가용 메모리 풀에 반환하는 과정

변수의 존속기간 : 변수가 특정 메모리 위치에 바인딩되어 있는 기간
존속기간 시작 시점 : 변수가 특정 셀에 바인딩될 때
   종료 시점 : 그 변수의 바인딩이 그 셀로부터 해제될 때

정적 변수 : 프로그램 실행이 시작되기 전에 메모리 셀에 바인딩되고 종료될 때까지 동일한 메모리 셀에 바인딩 (과거 민감 부프로그램에서 사용)
   장점 : 정적 변수에 대한 모든 주소지정은 직접적이고, 실행 시간에 정적 변수의 할당과 회수를 위한 부담이 없다는 효율성이 있다
   단점 : 재귀적 부프로그래밍을 지원하지 않음 -> 유연성 감소
           기억공간이 변수들 간에 공유될 수 없음

스택-동적 변수 : 변수의 선언문이 실제 실행될 때, 기억공간에 바인딩 (변수의 타입은 정적으로 바인딩_
   장점 : 재귀적 부프로그램 사용가능 -> 유연성 증가
   단점 : 할당과 회수에 따른 실행 시간 부담
           스택에서의 위치가 계속 바뀌면서 간접 주소지정이 요구되기 때문에 접근이 느려짐
           부프로그램이 과거 민감 할 수 없음

명시적 힙-동적 변수 : 프로그래머가 명세하는 명시적 실행 시간 명령어에  의해서 할당되고 회수되는 이름이 없는 추상 메모리 셀을 의미 -> 힙으로 부터 할당, 회수 (단지 포인터나 참조 변수를 통해 참조될 수 있음)
   장점 : 연결 리스트나 트리와 같은 동적 구조체 구현 가능
   단점 : 포인터나 참조 변수의 올바른 사용의 어려움
           요구된 기억공간 관리 구현의 복잡성

묵시적 힙-동적 변수 : 값이 배정될 때에 힙 기억 장소에 바인딩
   장점 : 언제 어던 타입으로도 변경 가능하며, 메모리 위치도 자동 변경 (최고의 유연성)
   단점 : 모든 동적 속성들을 유지하는데 필요한 실행-시간 부담

영역 : 변수가 가시적인 문장들의 범위
가시적 : 변수가 어떤 문장에서 참조 될 수 있는 것

정적 영역 : 변수의 영역이 정적으로, 즉 실행 전에 결정됨
블록 : 코드의 부분

전역 변수의 영역 :  파일에 속한 함수 외부에 위치한 변수 정의로 인해 생성되며 모든 함수들에게 가시적임
전역 변수의 정의 : 변수의 속성 명세, 기억공간의 할당 야기
전역 변수의 선언 : 변수의 속성 명세, 기억공간의 할당 야기x

동적 영역 : 부프로그램들의 상호 공간적 배치 관계가 아닌 부프로그램들의 호출 시퀸스에 기반하여 변수의 영역을 결정 -> 컴파일 시간에 결정 못함


참조 환경 : 그 문장에서 가시적인 모든 이름의 집합
정적 영역 언어의 참조 환경 : 그 지역 영역에 선언된 변수 + 조상 영역에 속한 가시적인 모든 변수

------------------------------------
데이터 타입 : 데이터 값들의 모임과 그들 값들에 대한 미리 정의된 연산의 집합
사용자 정의 타입 : 타입에 대한 의미있는 이름 사용을 통해 향상된 판독성 제공, 프로그램 수정에 도움 (타입 선언문 변경을 통해 어떤 부류의 변수들에 대한 타입 변경 가능)

기본 데이터 타입 : 다른 데이터 타입을 이용하여 정의되지 않은 데이터 타입 (단, 어떤 데이터 타입은 단지 하드웨어의 반영)

수치 타입 : 숫자와 관련된 기본 타입
정수 : 가장 공통된 기본 수치 데이터 타입
부동-소수점 수 : 실수를 모델링 (단지 근사값 제공)

불리안 타입 : 값들의 범위로 참, 거짓 두 개의 요소를 가지며 모든 타입들 중에서 가장 단순한 타입
c언어의 불리안 타입 : 불리안 타입을 지원하지 않으며 0을 거짓, 0이 아닌 모든 값을 참으로 처리 -> 수치 식을 불리안 식처럼 사용 (장점이자 단점, 무한 루프 유발 가능)

문자 타입 : 문자 데이터는 수치 코딩으로 컴퓨터에 저장 (문자 타입은 개수가 제한되어 있는 discrete한 언어이기 때문에 정수에 mapping이 가능)
파이썬의 문자 타입 : 단지 길이가 1인 문자열
ASCII : 8bit, Unicode : 16bit, UCS-4 UTF-32 : 4byte

문자 스트링 타입 : 값들이 일련의 문자들로 구성되는 타입
스트링 연산 : 배정, 접합, 부분 스트링 참조(슬라이스), 비교, 패턴 매칭
c언어 스트링 : 문자들의 배열 (끝은 항상 null 문자로 처리), 스트링 연산이 기본 제공되지 않으며 라이브러리 함수 이용
   문제 : 라이브러리가 오버플로에 대한 보호를 하지 않음
자바 스트링 : string class(immutable), stringbuffer class(mutable)
파이썬 스트링 : immutable
스트링의 불변 : 값이 변경되는 것이 아닌 단지 새로운 문자열 참조

정적 길이 스트링 : 길이 정적, 스트링 생성시 결정 (자바 string class, 파이썬 string)
컴파일 타임 서술자 : 단지 컴파일 과정에서만 요구되며 이름, 길이, 주소 세가지 필드를 가짐

제한된 동적 스트링 : 스트링이 그 변수 정의에서 선언되고 고정된 최대 길이까지의 가변적인 길이를 갖는 것을 허용하는 스트링 (c string)
실시간 타임 서술자 : 고정된 최대 길이와 현재 길이를 저장
        서술자는 대부분 심볼 테이블에 저장 (단 c언어는 끝이 널 문자이기 때문에 실시간 타임 서술자를 요구하지 않으며 배열 길이 검사를 하지 않기 때문에 최대 길이도 사용 x)

동적 길이 스트링 : 최대 길이 제한 없이 가변 길이를 갖는 것을 허용 (java stringbuffer class), 더 복잡한 기억공간 관리 요구, 스트링의 길이와 이에 바인딩되는 기억공간은 동적으로 늘고 줄음
   접근 방법 : 연결 리스트 이용 : 스트링이 늘어날 때, 새롭게 요구된 메모리 셀들은 힙의 어느 곳으로부터 올 수 있음
         단점 : 연결 리스트의 링크 표현을 위한 여분 메모리 필요
                 스트링 연산의 복잡성
         포인터 배열 이용 : 스트링을 힙에 할당된 개개의 문자들을 가리키도록 하는 방법
         장점 : 연결 리스트 접근에 비해 빠르다
         단점 : 포인터 배열을 위한 여분 메모리
                 포인터의 배열 또한 길이가 제한
         기억공간 셀들에 저장 : 기억 공간 여유가 없을 경우 탐색, 이전, 회수 순서 -> 동적 길이 스트링에서 주로 이용

순서 타입 : 가능한 값들의 범위가 0과 야의 정수 집합과 쉽게 연관될 수 있는 타입 (java의 int, char, boolean)
사용자 정의 순서 타입 : 열거, 부분 범위
열거 타입 : 이름 상수들인 모든 가능한 값들이 그 정의에서 제공되는, 즉 제공되는 타입
     열거 상수라 불리는 이름 상수들의 모임을 정의, 그루핑하는 방법 제공
   장점 : 사용자가 알아보기 쉬운 이름 상수들을 이용하기 때문에 코드가 더 명확해서 판독성 증가
           신뢰성 (자바, c는 x)


배열 : 동질적인 데이터 원소들의 집합체 (개개의 모든 데이터 원소들은 동일 타입) <-> 이질적인 데이터 원소 집합체 = 구조체
        개개인의 원소는 집단체의 첫 번쨰 원소와의 상대적인 위치(offset)에 의해 식별
c. java 배열 : 모든 원소들은 동일한 타입에 속해야 함, 포인터나 참조 또한 단일 타입을 가리키거나 참조하도록 제한 -> 참조되는 객체나 데이터 값들도 단일 타입
python 배열 : 객체나 데이터 값들에 대한 타입과 상관없는 typeless 참조들
         typeless라는 단일 타입의 원소들로 구성, 그 원소들은 다른 타입의 객체 또는 데이터 값 참조 가능 (원소들은 동질적)
배열의 특정 원소 참조 : 집단체 이름 + 첨자
유한 사상 : 선택 연산은 배열 이름과 첨자 값들의 집합으로부터 집단체의 한 원소로의 사상 (배열 = 유한 사상)
첨자 범위 오류 : 범위 검사는 언어의 신뢰성에 중요한 요소

첨자 바인딩 : 배열 변수에 대한 첨자 타입의 바인딩은 보통 정적, 첨자 값 범위는 때때로 동적 바인딩

정적 배열 : 첨자 범위 정적, 기억공간 할당 정적
   장점 : 동적 할당, 회수가 요구되지 않기 때문에 실행 시간 효율성
   단점 : 배열에 대한 기억공간이 프로그램 실행 시간 전체에 걸쳐서 고정 -> 메모리 사용 측면에서 비효율적

세련화(declaration elaboration time) : 메모리를 할당하고 그것을 바인딩
고정 스택-동적 배열 : 첨자 범위 정적, 기억공간 할당 실행 시간 중(선언문 세련화 시간) (c언어 static 배열)
   장점 : 정적 배열에 비해 기억 공간의 효율성 존재 (활성화 시간이 제한적)
   단점 : 할당과 회수에 소요되는 실행 시간

스택-동적 배열 : 첨자 범위, 기억공간 할당 세련화 시간에 동적 -> 첨자 범위 바인딩과 기억 공간 할당 이후 변수의 존속기간 동안 고정 (c언어 배열)
   장점 : 배열의 크기가 배열 사용 전까지 미리 알려질 필요 없기 때문에 앞선 두 가지에 비해 유연함

고정 힙-동적 배열 : 첨자 범위, 기억공간 바인딩 기억공간 할당 이후 고정 (c언어 malloc, java의 비 포괄적 배열)
   고정 스택-동적 배열과의 차이점 : 첨자 범위, 기억공간 바인딩이 실행 중에 사용자 프로그램의 요청으로 이루어짐
                  기억공간이 스택이 아닌 힙에서 할당
   장점 : 배열의 크기는 항상 문제에 맞춤화되기 때문에 유연함
   단점 : 스택으로부터 할당 시간보다 힙으로부터의 할당 시간이 더 오래 걸림

힙-동적 배열 : 첨자 범위 바인딩, 기억공간 할당 동적 (자바 arraylist 첨자 사용x, python 배열)
          배열의 존속기간 동안 여러 번 변경 가능
   장점 : 실행 중 기억공간의 필요가 변화함에 따라 늘어나거나 줄어들 수 있기 때문에 유연함
   단점 : 할당의 회수 시간이 길어지며, 할당과 회수가 실행 중 여러 번 발생 가능

배열 연산 : 배정, 접합, 동등과 비동등 비교, 슬라이스
c언어 배열 연산 : 제공 x
java 배열 연산 : method를 통해 제공
python 배열 연산 : 동적 배열의 모든 특성을 가지지만 list로 불림
      단지 참조 변경이지만 배정 연산 제공
      비교 연산 is = 참조값 비교, == = 내용 비교
      슬라이스 연산 제공
