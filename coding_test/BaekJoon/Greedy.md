# Greedy

#### 11509번 : 풍선 맞추기 (골드5)*
  * 문제 유형 : greedy
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - 높이별 존재하는 풍선의 개수를 저장하는 dp 배열 이용
  - 풍선의 위치를 순서대로 입력받을 때 현재 위치보다 앞선 풍선 중에 높이가 1 높은 풍선이 존재하면 다트가 날아오면서 현재 풍선은 자연스럽게 터지게 되기 때문에 선행 높이의 풍선 수를 줄이고 현재 높이의 풍선 수를 1 증가시킴
  - 높이가 1 높은 선행 풍선이 존재하지 않으면 다트를 무조건 하나 더 던저야 현재 풍선이 터지기 때문에 총 다트 수를 증가시킴
  ```

#### 3109번 : 빵집 (골드2)
  * 문제 유형 : greedy, graph, dfs
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 :
  ```
  - 맨 왼쪽 열의 한 노드부터 맨 오른쪽 열의 한 노드까지 서로 겹치지 않고 이어지는 경로의 최대 개수를 구하는 문제이기 때문에 dfs 사용
  - 어느 한 노드에서 바로 오른쪽 열의 노드로 갈 수 있는 경우의 수는 오른쪽 대각선 위, 오른쪽, 오른쪽 대각선 아래 3가지
  - 맨 위쪽 행부터 시작하여(stack에 넣는 순서도 반대로하면 반대여도 무관) 경로를 찾을 경우 최대한 위쪽에 치우친 경로를 만들어야 이후 경로에 영향을 끼칠 확률이 줄어들기 때문에 오른쪽 대각선 아래, 오른쪽, 오른쪽 대각선 위 순으로 stack에 add(stack은 후입선출 방식이기 때문)
  - stack에 push할때 visit을 true로 체크 할 경우 이후 다른 경로를 택 해야할 경우 사용하지 않는 노드 또한 방문한 것이 되기 때문에 stakc에서 pop한 후 다음 경로가 존재하는 경우에만 visit을 true로 체크
  - stack에서 pop한 노드의 위치가 맨 오른쪽 열일 경우 조건에 만족하는 경로가 이어진 것이기 때문에 경로 개수를 증가
  ```

#### 1931번 : 회의실 배정 (실버1)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(n)
  * 풀이 방식 :
  ```
  - 회의 배열을 종료 시점을 기준으로 오름차순 정렬
  - 오름차순 된 배열의 첫 번째 값(가장 먼저 끝나는 회의)를 기준으로 이후 회의들과 비교하여 기준 회의의 종료 시점보다 비교 회의의 시작 시점이 빠르다면 무시하고, 시작 시점이 늦는다면 기준 회의를 비교 회의로 변경하고 사용가능한 회의 개수를 증가시켜 최대값을 구함
  ```
  
#### 13164번 : 행복 유치원 (골드5)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(n)
  * 풀이 방식 :
  ```
  - n명의 사람으로 k개의 그룹을 만들기 위해선 n-k번 합쳐야 함
  - 각 그룹의 최대 키와 최소 키의 차는 키가 인접한 어린이들의 키 차이를 모두 더한 것과 같음
  - 따라서 어린이들의 키 차이를 배열에 저장하고 오름차순으로 정렬하여 가장 작은 키 차이 n-k개를 선택하면, 가장 큰 어린이와 가장 작은 어린이의 키 차이의 총 합이 가장 작은 그룹 k개를 만드는 것과 같게 됨
  ```
  
#### 1092번 : 배 (골드5)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(nmlogm)
  * 풀이 방식 :
  ```
  - 크레인 정보와 박스 무게 정보를 입력 받아 각각 리스트에 저장
  - 두 리스트을 무게를 기준으로 내림차순 정렬
  - 가장 무거운 무게를 들 수 있는 크레인에 가장 무거운 박스를 들어야 최소 시간안에 모든 박스를 옮김
  - 모든 박스를 옮길 때까지 크레인마다 박스 배열을 순회하며 들 수 있는 가장 무거운 박스를 remove (순회시 직전 크레인이 옮긴 박스 다음부터 시작)
  - 한 사이클마다 시간을 늘려 구해지는 최종 시간 출력
  ```
  
#### 1461번 : 도서관 (골드5)
  * 문제 유형 : greedy
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 최대한 먼 곳부터 옮길 수 있는 책 개수에 맞춰 책을 옮겨야 이동거리를 최소화 시킬 수 있음 (왕복하기 때문에)
  - 오른쪽으로 옮겨야되는 책(양수 좌표), 왼쪽으로 옮겨야되는 책(음수 좌표)을 두 개의 배열에 따로 저장하여 오름차순 정렬
  - 가장 멀리 옮겨야되는 위치부터(배열의 끝) 거리의 두 배를 총 이동거리에 더하고, 옮길 수 있는 책 개수만큼 인덱스를 줄임
  - 위 과정을 두 배열에서 시행하고, 가장 멀리 떨어진 위치는 왕복 할 필요가 없기 때문에 총 이동거리에서 뺌
  ```
  
#### 2212번 : 센서 (골드5)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(n)
  * 풀이 방식 :
  ```
  - 13164번 행복 유치원과 동일한 풀이 방법
  ```
  
#### 8980번 : 택배 (골드2)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(nm)
  * 풀이 방식 :
  ```
  - 택배 박스 정보를 저장하는 배열과 각 마을을 지나갈 때 트럭에 담겨있는 택배의 최대 박스 수를 저장하는 배열을 이용
  - 택배 박스 배열을 받는 마을번호 기준으로 오름차순 정렬
  - 정렬한 순서대로 각 택배의 시작마을부터 도착마을 직전까지 트럭에 담겨있는 최대 택배 박스 수를 찾음
  - 택배를 실을 경우 택배 박스 수와 최대 박스 수를 합친 수가 트럭 용량이 넘치면 용량에 맞게 일부 택배를, 넘치지 않으면 모든 택배 박수 수를 경로 상의 최대 박스 수 배열에다가 각각 더하고 배송 가능한 박스 수에도 카운팅함
  ```
  
#### 2457번 : 공주님의 정원 (골드3)
  * 문제 유형 : greedy
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 피는 날짜를 기준으로 꽃을 오름차순 정렬하는 우선순위 큐 이용
  - 3월 1일을 시작으로 현재 꽃이 피어있는 마지막 날짜(한계 날짜)를 3월 1일으로 설정하고 시작하여, 우선순위 큐에서 피는 날짜가 꽃의 한계 날짜보다 앞서는 모든 꽃을 빼내며 비교하여 가장 늦게 지는 꽃을 찾은 후 한계 날짜를 찾은 꽃의 지는 날짜로 바꿈
  - 한계 날짜가 이전과 같으면 더 이상 11월 30일까지 이을 수 있는 꽃이 없는 것이기 때문에 0 출력
  - 위의 과정을 한계 날짜가 12월 달이 될 때까지 반복하고 사용된 꽃의 개수를 출력
  ```

#### 10775번 : 공항 (골드2)*
  * 문제 유형 : greedy, union-find
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  -
  ```
  
#### 1700번 : 멀티탭 스케줄링 (골드1)*
  * 문제 유형 : greedy
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 :
  ```
  - 첫 번째 시도에서 입력과 동시에 멀티탭을 채우는 방법을 사용했는데 멀티탭에 빈 자리가 있을 때 이미 사용중인 전기용품인지를 체크하지 않고 채워넣어 실패 (멀티탭이 꽉 차 있을때만 체크하는 실수)
  - 멀티탭이 가득 찰 때까지 전기용품을 채워넣으며 boolean 배열을 이용해서 꽂혀있는 전기용품을 체크
  - 멀티탭이 가득 찬 상태라면 꽂혀있는 전기용품 중 이후 다신 사용하지 않는 기기가 1순위, 이후 사용 순서가 가장 나중인 기기가 2순위로 멀티탭에서 뽑은 뒤 다음 전기용품을 멀티탭에 꽂음
  - 리스트 배열을 이용해서 각 기기별로 이후 사용 순서를 저장하여 뽑을 기기를 선택할 때 만약 해당 기기의 리스트가 비어있으면 이후 사용할 일이 없음을 뜻하고, 비어있는 기기가 없다면 각 리스트의 첫 번째 값을 비교하여 가장 큰 값(가장 나중에 사용)을 가진 기기를 찾음
  - 이미 꽂혀있는 기기면 넘어감
  - 위 과정을 전기용품 사용 스케줄을 모두 완료할 때까지 반복하며 멀티탭에서 전기용품을 뽑는 횟수를 
  ```
  
---------------------------------
### Tree

#### 1135번 : 뉴스 전하기 (골드2)
  * 문제 유형 : greedy, sort, dp, tree
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 트리 정보를 인접리스트를 이용하여 저장
  - 재귀를 이용해서 리프 노드부터 자신의 아래 위치에 뉴스가 전해지는 데 가장 오래 걸리는 시간을 구하여 리턴
  - 자식 노드(직속 부하 직원)들의 직속 부하 직원 수를 배열에 저장하고 내림차순 정렬한 뒤 한 번에 한 사람에게만 전달 할 수 있기 때문에 배열의 앞에서부터 1씩 늘려가며 소요시간을 더함 (+1, +2, +3, ... , +n) (많은 부하 직원을 가진 부하 직원부터 가장 먼저 전달해야 시간 소요가 최소화)
  - 배열을 오름차순 재정렬한 뒤에 가장 앞에 있는 시간(가장 오래 걸리는 시간)을 리턴
  - 루트 노드(매니저)까지 진행 후 구해진 시간이 최소 시간
  ```

---------------------------------
### PriorityQueue

#### 13975번 : 파일 합치기 3 (골드4)
  * 문제 유형 : greedy, PriorityQueue
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 파일 크기를 기준으로 오름차순 정렬하는 우선순위 큐를 사용
  - 우선순위 큐에 들어있는 파일 개수가 1개일 경우 파일을 합칠 필요가 없기 때문에 우선순위 큐의 크기가 2개 이상일 때만 앞에 있는 요소 두 개를 꺼내서 합친 후 우선순위 큐에 집어넣는 과정을 반복해서 모든 파일을 합치는 데에 필요한 최소비용을 구함
  ```
  
#### 1374번 : 강의실 (골드5)*
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 강의 시작시간 기준으로 오름차순 정렬하는 우선순위 큐, 강의 종료시간 기준으로 오르마순 정렬하는 우선순위 큐를 사용
  - 강의 정보들을 입력 받아 첫 번째 우선순위 큐에 집어 넣은 뒤 가장 앞에 있는 강의(시작 시간이 가장 빠른 강의)를 빼내어 두 번째 우선순위 큐에 집어 넣는다
  - 이후 첫 번째 우선순위 큐가 빌 때까지 맨 앞에 있는 강의를 빼내어 두 번째 우선순위 큐 맨 앞에 있는 강의의 종료시간과 비교하여 시작시간이 앞서면 무조건 강의실이 하나 더 필요한 것이기 때문에 두 번째 우선순위 큐에 집어넣고, 시작시간이 늦으면 현재 강의실을 이어서 사용하면 되기 때문에 두 번째 우선순위 큐의 맨 앞 강의를 빼내고 현재 강의를 집어 넣음
  - 위의 과정 종료 후 두 번째 우선순위 큐의 사이즈(강의 시간이 겹쳐 추가적인 강의실이 필요하여 우선순위 큐에 넣어진 강의들)가 필요한 강의실에 개수 
  ```
  
#### 1826번 : 강의실 배정 (골드5)
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 1374번 강의실과 동일한 풀이
  ```

#### 1202번 : 보석 도둑 (골드2)*
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 보석 무게를 기준으로 오름차순 정렬하는 우선순위 큐, 보석 가격을 기준으로 내림차순 정렬하는 우선순위 큐를 사용
  - 가방 배열을 오름차순으로 정렬한 뒤, 배열을 순회하며 현재 가방의 용량보다 무게가 적게 나가는 모든 보석들을 우선순위 큐에서 빼내어 두 번째 우선순위 큐에 집어넣음
  - 하나의 가방을 체크할 때마다 두 번째 우선순위 큐의 맨 앞의 보석이 현재 가방에 담을 수 있는 가장 비싼 보석이 되기 때문에 하나를 빼서 총 보석값에 더함
  ```

#### 13904번 : 제출 (골드3)*
  * 문제 유형 : greedy, PriorityQueue
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 점수를 많이 얻을 수 있는 과제를 최대한 마감일에 맞춰서 푸는 것이 포인트
  - 점수 기준으로 내림차순 정렬하는 우선순위 큐, 과제별 완료 날짜를 체크하는 boolean 배열 check을 사용
  - 모든 과제를 입력받아 우선순위 큐에 집어 넣음
  - 우선순위 큐에서 과제를 하나씩 빼내어 check배열을 이용해 과제의 마감일부터 시작하여 1일차까지 비어있는 날짜가 있다면 해당 날짜에 과제를 해결 (현재 점수를 많이 얻을 수 있는 과제를 최대한 마감일에 맞춰서 해결하는 과정)
  - 이 풀이방법은 케이스가 적은 문제이기 때문에 가능하며 케이스가 많은 경우의 풀이법은 1781번 컵라면 참고
  ```

#### 1781번 : 컵라면 (골드2)
  * 문제 유형 : greedy, PriorityQueue
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 컵라면을 많이 얻을 수 있는 문제를 최대한 데드라인에 맞춰서 푸는 것이 포인트
  - 데드라인 기준으로 내림차순 정렬하는 우선순위 큐, 컵라면 수 기준으로 내림차순 정렬하는 우선순위 큐를 사용
  - 모든 문제를 첫 번째 우선순위 큐에 집어넣어 정렬
  - 최대 시간부터  해당 시간에 할 수 있는 문제들을 첫 번째 우선순위 큐로부터 모두 빼내어 두 번째 우선순위 큐에 집어넣고, 두 번째 우선순위 큐의 맨 앞 문제를 빼내어 얻을 수 있는 컵라면을 총 컵라면 수에 더함(해당 시간에 얻을 수 있는 최고 컵라면 수)
  - 위의 과정을 데드라인 1시간까지 반복하여 받을 수 있는 최대 컵라면 수 출력
  ```
  
#### 1826번 : 연료 채우기 (골드3)
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 주유소와의 거리를 기준으로 오름차순 정렬하는 우선순위 큐, 연료량 기준으로 내림차순 정렬하는 우선순위 큐를 사용
  - 주유소들을 첫 번째 우선순위 큐에 집어넣고, 현재 트럭에 있는 연료로 갈 수 있는 주유소를 우선순위 큐에서 모두 빼내어 두 번째 우선순위 큐에 집어넣음
  - 두 번째 우선순위 큐에서 맨 앞의 주유소(현재 들릴 수 있는 주유소중 연료를 가장 많이 가지고 있는 곳)을 빼내어 보유 연료량에 더함
  - 위의 과정을 목적지를 지나갈 때까지 반복하며 만약 목적지에 도착하지 못 했는데 진행이 불가능하면 break하고 -1 출력
  - 기존 풀이 방식은 현재 갈 수 있는 주유소 중 연료가 가장 많은 주유소로 위치를 이동하면서 다음 위치로 이동을 위해 들러야 할 주유소가 현재 위치의 이전에 있는지 이후에 있는지 경우를 나누어 진행함
  - 간결화 된 풀이법은 가지고 출발한 연료와 중간에 들릴 수 있는 주유소의 연료량을 합쳐서 목적지까지 갈 수 있는지만 확인하면 됨 (즉, 기준을 무조건 시작점으로 잡음)
  ```
