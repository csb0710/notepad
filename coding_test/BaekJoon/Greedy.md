# Greedy

#### 11509번 : 풍선 맞추기 (골드5)*
  * 문제 유형 : greedy
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - 높이별 존재하는 풍선의 개수를 저장하는 dp 배열 이용
  - 풍선의 위치를 순서대로 입력받을 때 현재 위치보다 앞선 풍선 중에 높이가 1 높은 풍선이 존재하면 다트가 날아오면서 현재 풍선은 자연스럽게 터지게 되기 때문에 선행 높이의 풍선 수를 줄이고 현재 높이의 풍선 수를 1 증가시킴
  - 높이가 1 높은 선행 풍선이 존재하지 않으면 다트를 무조건 하나 더 던저야 현재 풍선이 터지기 때문에 총 다트 수를 증가시킴
  ```

#### 3109번 : 빵집 (골드2)
  * 문제 유형 : greedy, graph, dfs
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 :
  ```
  - 맨 왼쪽 열의 한 노드부터 맨 오른쪽 열의 한 노드까지 서로 겹치지 않고 이어지는 경로의 최대 개수를 구하는 문제이기 때문에 dfs 사용
  - 어느 한 노드에서 바로 오른쪽 열의 노드로 갈 수 있는 경우의 수는 오른쪽 대각선 위, 오른쪽, 오른쪽 대각선 아래 3가지
  - 맨 위쪽 행부터 시작하여(stack에 넣는 순서도 반대로하면 반대여도 무관) 경로를 찾을 경우 최대한 위쪽에 치우친 경로를 만들어야 이후 경로에 영향을 끼칠 확률이 줄어들기 때문에 오른쪽 대각선 아래, 오른쪽, 오른쪽 대각선 위 순으로 stack에 add(stack은 후입선출 방식이기 때문)
  - stack에 push할때 visit을 true로 체크 할 경우 이후 다른 경로를 택 해야할 경우 사용하지 않는 노드 또한 방문한 것이 되기 때문에 stakc에서 pop한 후 다음 경로가 존재하는 경우에만 visit을 true로 체크
  - stack에서 pop한 노드의 위치가 맨 오른쪽 열일 경우 조건에 만족하는 경로가 이어진 것이기 때문에 경로 개수를 증가
  ```

#### 1931번 : 회의실 배정 (실버1)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(n)
  * 풀이 방식 :
  ```
  - 회의 배열을 종료 시점을 기준으로 오름차순 정렬
  - 오름차순 된 배열의 첫 번째 값(가장 먼저 끝나는 회의)를 기준으로 이후 회의들과 비교하여 기준 회의의 종료 시점보다 비교 회의의 시작 시점이 빠르다면 무시하고, 시작 시점이 늦는다면 기준 회의를 비교 회의로 변경하고 사용가능한 회의 개수를 증가시켜 최대값을 구함
  ```
  
#### 13164번 : 행복 유치원 (골드5)
  * 문제 유형 : greedy, sort
  * 시간 복잡도 : O(n)
  * 풀이 방식 :
  ```
  - n명의 사람으로 k개의 그룹을 만들기 위해선 n-k번 합쳐야 함
  - 각 그룹의 최대 키와 최소 키의 차는 키가 인접한 어린이들의 키 차이를 모두 더한 것과 같음
  - 따라서 어린이들의 키 차이를 배열에 저장하고 오름차순으로 정렬하여 가장 작은 키 차이 n-k개를 선택하면, 가장 큰 어린이와 가장 작은 어린이의 키 차이의 총 합이 가장 작은 그룹 k개를 만드는 것과 같게 됨
  ```
 
 ---------------------------------
### PriorityQueue

#### 13975번 : 파일 합치기 3 (골드4)
  * 문제 유형 : greedy, PriorityQueue
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 파일 크기를 기준으로 오름차순 정렬하는 우선순위 큐를 사용
  - 우선순위 큐에 들어있는 파일 개수가 1개일 경우 파일을 합칠 필요가 없기 때문에 우선순위 큐의 크기가 2개 이상일 때만 앞에 있는 요소 두 개를 꺼내서 합친 후 우선순위 큐에 집어넣는 과정을 반복해서 모든 파일을 합치는 데에 필요한 최소비용을 구함
  ```
  
#### 1374번 : 강의실 (골드5)*
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 강의 시작시간 기준으로 오름차순 정렬하는 우선순위 큐, 강의 종료시간 기준으로 오르마순 정렬하는 우선순위 큐를 사용
  - 강의 정보들을 입력 받아 첫 번째 우선순위 큐에 집어 넣은 뒤 가장 앞에 있는 강의(시작 시간이 가장 빠른 강의)를 빼내어 두 번째 우선순위 큐에 집어 넣는다
  - 이후 첫 번째 우선순위 큐가 빌 때까지 맨 앞에 있는 강의를 빼내어 두 번째 우선순위 큐 맨 앞에 있는 강의의 종료시간과 비교하여 시작시간이 앞서면 무조건 강의실이 하나 더 필요한 것이기 때문에 두 번째 우선순위 큐에 집어넣고, 시작시간이 늦으면 현재 강의실을 이어서 사용하면 되기 때문에 두 번째 우선순위 큐의 맨 앞 강의를 빼내고 현재 강의를 집어 넣음
  - 위의 과정 종료 후 두 번째 우선순위 큐의 사이즈(강의 시간이 겹쳐 추가적인 강의실이 필요하여 우선순위 큐에 넣어진 강의들)가 필요한 강의실에 개수 
  ```
  
#### 1202번 : 보석 도둑 (골드2)*
  * 문제 유형 : greedy, PriorityQueue, sort
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 보석 무게를 기준으로 오름차순 정렬하는 우선순위 큐, 보석 가격을 기준으로 내림차순 정렬하는 우선순위 큐를 사용
  - 가방 배열을 오름차순으로 정렬한 뒤, 배열을 순회하며 현재 가방의 용량보다 무게가 적게 나가는 모든 보석들을 우선순위 큐에서 빼내어 두 번째 우선순위 큐에 집어넣음
  - 하나의 가방을 체크할 때마다 두 번째 우선순위 큐의 맨 앞의 보석이 현재 가방에 담을 수 있는 가장 비싼 보석이 되기 때문에 하나를 빼서 총 보석값에 더함
  ```

#### 1781번 : 컵라면 (골드2)
  * 문제 유형 : greedy, PriorityQueue
  * 시간 복잡도 : O(nlogn)
  * 풀이 방식 :
  ```
  - 컵라면을 많이 얻을 수 있는 문제를 최대한 데드라인 끝에 맞춰서 푸는 것이 포인트
  - 데드라인 기준으로 내림차순 정렬하는 우선순위 큐, 컵라면 수 기준으로 내림차순 정렬하는 우선순위 큐를 사용
  - 모든 문제를 첫 번째 우선순위 큐에 집어넣어 정렬
  - 최대 시간부터 해당 시간에 할 수 있는 문제들을 첫 번째 우선순위 큐로부터 모두 빼내어 두 번째 우선순위 큐에 집어넣고, 두 번째 우선순위 큐의 맨 앞 문제를 빼내어 얻을 수 있는 컵라면을 총 컵라면 수에 더함(해당 시간에 얻을 수 있는 최고 컵라면 수)
  - 위의 과정을 데드라인 1시간까지 반복하여 받을 수 있는 최대 컵라면 수 출력
  ```
