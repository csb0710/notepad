# Implementation

#### 14503번 : 로봇 청소기 (골드5)
  * 문제 유형 : implement, simulation
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 0은 북쪽, 1은 동쪽, 2는 남쪽, 3은 서쪽이기 때문에 왼쪽으로 방향을 돌리고 한 칸을 이동하는 과정을 현재 방향을 나타내는 인덱스에서 1을 빼고 4를 더한 뒤 4로 나눈 나머지를 구하는 방식으로 구현
  - 만약 4방향을 모두 둘러 봤을 때 이동할 곳이 없으면 벽이 아닌한 후진하여 이동하는데 이 경우 청소 구역 수를 증가시키지 않음
  - 더 이상 이동이 불가하면 총 청소 구역 수를 출력
  ```

#### 16236번 :  아기 상어 (골드3)
  * 문제 유형 : graph, bfs, implement, simulation
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 상어가 먹을 수 있는 물고기들을 선택할 때 가장 가까운 거리에 위치한 물고기 중 선택해야하기 때문에 bfs를 이용
  - 거리가 같은 물고기일 경우 가장 왼쪽에 위치한 물고기, 왼쪽 거리도 같다면 가작 위쪽에 위치한 물고기를 선택해야하기 때문에 이에 맞게 우선순위큐의 compare 조건을 지정
  - 거리 1당 시간이 1씩 걸리기 때문에 선택한 물고기로 이동할 때마다 떨어진 거리(물고기까지의 bfs시행 횟수)만큼 더하여 총 이동 시간을 구한다
  ```

#### 17143번 :  낚시왕 (골드1)
  * 문제 유형 : implement, simulation
  * 시간 복잡도 : O(n(m^2))
  * 풀이 방식 : 
  ```
  - 
  ```

#### 17135번 : 캐슬 디펜스 (골드3)
  * 문제 유형 : graph, implementation, simulation, bruteforce
  * 시간 복잡도 : O(mC3*nm^2)
  * 풀이 방식 : 
  ```
  - m개의 열 중 궁수 자리 3개를 고르는 모든 경우에서 적을 제거 해봐야하기 때문에 벡트레킹을 이용해서 궁수의 자리를 지정
  - *첫 풀이에서는 모든 적을 아래로 한 칸씩 이동시켰지만, 역으로 궁수 행을 위로 이동시키면 시간을 줄일 수 있음
  - 궁수 행의 첫 위치는 r이며 궁수의 위치가 1까지 가게 되면 반복이 종료 됨(0이면 어차피 쏠 적군이 존재하지 않음)
  - 궁수 행 이동 전 각 궁수 위치부터 (위, 오른쪽, 왼쪽)방향으로만 bfs탐색(각 반복마다 q의 사이즈를 체크하고 사이즈만큼 한 번에 탐색 -> 떨어진 거리가 같은 노드들을 한 사이클에 함께 탐색하기 위함)을 진행
  - 가장 가까운 적군이 존재하는 노드들 중 가장 왼쪽에 있는 노드를 선택하여 궁수 3명의 타겟을 저장하는 배열에 해당 궁수 인덱스에 저장
  - 3명의 궁수가 타겟을 정하게 되면 중복되지 않게 제거되는 적의 수를 카운팅(중복 사격이 가능하기 때문에 bfs탐색에서 적군을 발견하자마자 제거가 아닌 따로 배열에 저장 후 한 번에 처리해야 함)
  - 궁수를 배치하는 모든 경우에서 가장 많이 제거한 적군의 수를 출력
  ```
