# Graphs


#### 2252번 : 줄 세우기 (골드3)
  * 문제 유형 : graph
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - Queue, 각 노드의 선행 노드 개수를 의미하는 배열, 각 노드의 후위 노드를 저장하는 ArrayList를 이용
  - 선행 노드의 개수가 0인 노드를 Queue에 넣고, 하나씩 빼내어 출력, 후위 노드들의 각 선행 노드 개수를 줄인다
  - 만약 선행 노드의 개수가 0이 되면 Queue에 집어넣으며 이 과정을 Queue가 빌 때까지 반복 (만약 출력한 노드의 수와 총 노드의 수가 다르면 사이클 존재 -> 위상정렬 개념, 이 문제에는 해당 입력 case가 존재하지 않음)
  ``` 

#### 1516번 : 게임 개발 (골드3)
  * 문제 유형 : dp
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - 기존의 위상 정렬은 동시간대에 선택되는 정점까지 따질 필요는 없었지만, 각 건물(노드)들의 최소 완성 시간을 구해야하기 때문에 선행 건물의 건설 시간 중 가장 오래 걸리는 시간을 알아야한다
  - 따라서 queue를 사용하던 위상 정렬과 달리 건설 시간을 오름차순 기준으로 정렬하는 우선순위 큐를 이용하여 위상 정렬
  - 선행 노드의 개수가 0이 되면 먼저 앞선 건물들의 건설 시간을 현재 건물의 건설 시간에 더한 후 우선순위 큐에 넣어야 정확한 각 건물별 최소 완성 시간을 구할 수 있음
  ```
  
#### 1766번 : 문제집 (골드2)
  * 문제 유형 : dp
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - 위상 정렬을 이용하지만 선행 노드가 0이 되어 출력 할 때 문제 난이도가 쉬운 것부터 풀어야하기 때문에 큐 대신에 문제 난이도를 기준으로 오름차순 정렬하는 PriorityQueue를 이용
  ```
  
#### 1238번 : 파티 (골드3)*
  * 문제 유형 : dp, graph
  * 시간 복잡도 : O(case*(V+E))
  * 풀이 방식 : 
  ```
  - 우선순위 큐와 위상정렬을 이용하는 풀이법(1516번 게임 개발)을 각 case별로 적용
  ```
  
#### 1516번 : ACM Craft (골드3)
  * 문제 유형 : dp, graph
  * 시간 복잡도 : O(case*(V+E))
  * 풀이 방식 : 
  ```
  - 우선순위 큐와 위상정렬을 이용하는 풀이법(1516번 게임 개발)을 각 case별로 적용
  ```

-------------------------------------------------
### bfs

#### 7576번 : 토마토 (골드5)
  * 문제 유형 : graphs, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 하루마다 익은 토마토별로 인접한 한 칸씩 익기 때문에 bfs 탐색을 이용
  - 모든 토마토가 익는 시간을 정확히 재기 위해선 하루마다 익은 토마토와 인접한 토마토만 익어야 되기 때문에 반복할 때마다 큐의 사이즈만큼만 토마토를 빼내어 bfs 탐색을 진행해야 함
  - 더 이상 익을 수 있는 토마토가 없을 때 (큐가 비었을 때) 총 토마토의 개수와 익은 토마토의 개수를 비교하여 모든 토마토가 익을 수 있는지 
  ```
  
#### 7569번 : 토마토 (골드5)
  * 문제 유형 : graphs, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 7576번 토마토에서 상자가 수직으로 쌓아 올려지는 형태로 4방향 탐색이 아닌 위, 아래를 포함한 6방향 탐색 진행
  ```
  
#### 10026번 : 적록색약 (골드5)
  * 문제 유형 : graphs, bfs, dfs
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 서로 같은 색깔이면서 이어져있는 구역의 개수를 정상인의 시선과 적록색약의 시선의 경우를 각각 구해야하기 때문에 dfs와 bfs 모두 가능
  - 정상인 시선의 경우 아직 방문하지 않은 노드를 시작 색깔로 하고 일반적인 bfs 탐색을 해서 구역의 개수를 구함
  - 적록색약 시선의 경우 동일하게 아직 방문하지 않은 노드를 시작 색깔로 하고 bfs 탐색을 하지만 시작 색깔이 빨간색 혹은 초록색일 경우 서로 색깔 구분을 하지 않고 탐색해서 구역의 개수를 구함
  ```  

#### 14502번 : 연구소 (골드4)*
  * 문제 유형 : graphs, bfs, dfs, implementation, simulation, bruteforce
  * 시간 복잡도 : O((nm)^3)
  * 풀이 방식 : 
  ```
  - 바이러스를 인접한 4방향으로 계속해서 퍼트린 후 안전 영역을 구하면 되기 때문에 dfs, bfs 모두 가능
  - 백트레킹을 이용해서 벽 3개를 세울 수 있는 모든 경우에서 바이러스를 시작점으로 bfs 탐색을 진행
  - 벽 3개가 세워진 각 경우마다 시뮬레이션을 각각 진행해야 되기 때문에 연구소 지도를 복사해서 사용
  - 바이러스가 퍼질때마다 안전 영역의 크기를 줄이면서 가장 큰 안전 영역의 크기를 구함
  ```
  
#### 4179번 : 불! (골드4)
  * 문제 유형 : graphs, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 세준이가 미로를 통과하는 가장 빠른 탈출 시간을 구해야 하기 때문에 bfs를 이용
  - 세준이와 불의 속도가 같기 때문에 방문 체크를 하는 visit배열을 공유해서 사용해도 됨 (이미 세준이가 지나간 경로에 번지는 불은 세준이의 이후 경로에 영향을 끼치지 못하기 때문에)
  - 불과 세준이의 bfs 탐색을 따로 진행해야하기 때문에 두 개의 큐를 사용하며, 시간 당 불과 세준이는 4방향으로 1칸씩 움직일 수 있기 때문에 반복 할 때마다 각각의 큐 사이즈만큼씩만 노드를 빼내어 bfs 탐색 진행
  - 불과 세준이가 동시에 만나는 경로는 갈 수 없는 경로이기 때문에 무조건 불의 bfs 탐색을 먼저 진행
  - 위의 과정을 세준이의 경로를 저장하는 큐가 빌 때까지(세준이가 더 이상 이동하지 못할 때까지) 반복
  - 세준이가 미로의 가장자리에 처음 도달 했을 때가 가장 빠른 탈출 시간이기 때문에 반복문 즉시 종료
  ```

#### 3055번 : 탈출 (골드4)
  * 문제 유형 : graphs, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 물이 침범 할 수 없는 목적지(비버의 굴)  하나가 존재한다는 점 외에는 4179번 불! 문제와 풀이방법이 동일
  ```

#### 16236번 : 아기 상어 (골드3)
  * 문제 유형 : graphs, bfs, implementation, simulation
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 상어가 먹을 수 있는 물고기들을 선택할 때 가장 가까운 거리에 위치한 물고기 중 선택해야하기 때문에 bfs를 이용
  - 거리가 같은 물고기일 경우 가장 왼쪽에 위치한 물고기, 왼쪽 거리도 같다면 가작 위쪽에 위치한 물고기를 선택해야하기 때문에 이에 맞게 우선순위큐의 compare 조건을 지정
  - 떨어진 거리가  물고기들만 우선순위 큐에 들어가야하기 때문에 현재 큐의 크기만큼만 빼내어 탐색
  - 거리 1당 시간이 1씩 걸리기 때문에 선택한 물고기로 이동할 때마다 떨어진 거리(물고기까지의 bfs시행 횟수)만큼 더하여 총 이동 시간을 구한다
  ```
  
#### 16234번 : 인구 이동 (골드5)
  * 문제 유형 : graphs, bfs, implementation, simulation
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 그래프 내의 노드들 중 방문하지 않은 노드에서 bfs 탐색
  - 현재 노드에서 4방향 탐색을 진행하여 인접한 노드와의 인구 격차가 L 이상 R 이하이면 해당 노드를 bfs queue와 연합 국가를 저장하는 queue에 넣고 인구값을 sum 변수에 더하고 연합 수를 의미하는 count 변수를 1 늘림
  - 하나의 연합을 모두 탐색 했다면 모든 연합 국가의 인구수를 총 인구수 / 연합 국가 수로 바꿈
  - 방문하지 않은 노드가 없을 때까지 bfs 탐색
  - 인구 이동이 일어나지 않을 때까지 위의 과정을 반복
  ```

#### 1707번 : 이분 그래프 (골드4)*
  * 문제 유형 : graphs, bfs, dfs
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - 이분 탐색 그래프 : 같은 그룹에 속한 정점끼리는 서로 인접하지 않도록 하는 그래프 (그래프를 두가지 색으로 칠할 때 bfs 탐색의 측면에서 같은 레벨의 노드는 같은 색을 가져야 함)
  - 간선의 정보를 인접 리스트에 저장
  - 인접 리스트를 이용해서 그래프를 전체 탐색하기 때문에 bfs, dfs 모두 가능
  - 방문 하지 않은 노드에 0 또는 1을 넣고, 인접한 노드들은 현재 노드와 반대되는 값을 넣으면서 bfs 탐색을 진행
  - bfs 탐색 진행 중 현재 노드의 값과 인접한 노드의 값이 같은 경우가 발생하면 이분 그래프 조건을 만족하지 않는 것
  - 무조건 모두 이어진 그래프가 아니기 때문에 방문하지 않은 노드를 찾아 위의 과정을 반복
  ```

#### 2206번 : 벽 부수고 이동하기 (골드3)*
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 시작 지점으로부터 목표 지점까지의 최소 거리를 구하는 문제이기 때문에 기존의 bfs 풀이방식을 이용
  - 벽을 1개를 부숴 길을 만들 수 있기 때문에 벽을 부수고 이동했을 때 보다 벽을 부수지 않고 이동했을 때가 더 최소값인 경우 기존의 visit배열을 사용했을 경우 탐색 불가
  - 기존의 visit 배열과는 다르게 벽을 부수지 않고 이동했을 때, 벽을 1개 부수고 이동했을 때의 visit배열을 따로 관리하기 위해 3차원 배열을 이용(visit[n][m][2])
  ```

#### 14442번 : 벽 부수고 이동하기2 (골드2)
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 2206번과 동일한 방법으로 visit 배열을 벽의 제한 갯수의 크기로 만들어 주고, 각 정점 방문시 따지는 조건 또한 갯수 제한에 따라 바꿔줌(visit[n][m][k])
  ```
  
#### 2573번 : 말이 되고픈 원숭이 (골드3)
  * 문제 유형 : implementation, graph, dfs, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 :
  ```
  - 시작 지점으로부터 목표 지점까지의 최소 거리를 구하는 문제이기 때문에 기존의 bfs 풀이방식을 이용
  - 원숭이의 이동 방법은 단순 4방향 탐색을 통한 1칸 이동과 8가지의 말 형태 이동 2가지
  - 말 이동을 사용했을 때보다 단순 1칸 이동을 했을 때 더 빨리 이동하는 경우가 있을 수 있기 때문에 말 이동 사용 횟수별 방문 체크를 따로 해줘야함 (3차원 visit배열 이용)
  - 먼저 기존의 4방향 탐색을 하고, 현재 원숭이의 말 이동 횟수가 남아있다면 8방향 탐색또한 진행 (말 이동은 중간에 벽이 있어도 상관 없음)
  ```
  
#### 19238번 : 스타트 택시 (골드3)
  * 문제 유형 : implementation, graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 :
  ```
  - 손님과 목적지로 가는 최소 경로를 찾아야하기 때문에 bfs 탐색을 이용
  - 택시에 손님이 타고 있지 않으면 우선순위 큐와 큐의  조건에 맞는 가장 가까운 손님을 찾아가 택시에 태움 (현재 위치에 손님이 서 있을 수 있기 때문에 현재 위치에서 손님 확인 또한 해야함)
  - 떨어진 거리가 똑같은 물고기들만 우선순위 큐에 들어가야하기 때문에 현재 큐의 크기만큼만 빼내어 탐색
  - 손님이 타고 있는 상태면 4방향 bfs 탐색을하여 목적지까지 찾아간 후 소모된 연료의 2배만큼 더함
  - 모든 손님을 택시에 태웠으면 남은 연료량을 출력
  ```
  
#### 2638번 : 치즈 (골드3)
  * 문제 유형 : graph, bfs, dfs
  * 시간 복잡도 : O(t*nm)
  * 풀이 방식 : 
  ```
  - 가장자리는 항상 치즈(1)이 없기 때문에 가장자리부터 연속적으로 이어지는 치즈가 아닌 빈 블록을 활용하는 방법을 사용하기 때문에 bfs와 dfs 모두 가능
  - visit 배열뿐만이 아니라 치즈의 공기 노출면의 개수를 체크하는 check 배열을 사용
  - (0, 0)부터 bfs 탐색을 시작하여 (i, j)가 공기(0)일 경우 queue에 집어 넣고, 치즈(1)일 경우 check[i][j]가 이미 true일 때는 해당 치즈를 없애고, false일 때는 공기 노출면이 적어도 하나 존재함을 나타내기 위해 check[i][j]를 true로 바꿔준다
  - 과정 반복 중 queue가 비었을 경우 1시간이 지나 공기 접촉면이 2개 이상인 테두리 치즈들이 녹은 것을 뜻하기 때문에 while문을 하나 더 이용하여 삭제 된 치즈의 개수가 처음 입력 받은 치즈의 총 개수와 같아질 때, 즉 모든 치즈가 삭제될 때까지 반복하여 총 시간을 구한다
  ```
  
#### 2573번 : 빙산 (골드4)
  * 문제 유형 : implementation, graph, dfs, bfs
  * 시간 복잡도 : O(t*nm)
  * 풀이 방식 :
  ```
  - 2중 for문을 이용하여 빙산 노드를 탐색
  - 탐색한 빙산 노드부터 시작하여 bfs 탐색을 시작
  - 현재 노드의 주변 노드가 바다면 노드의 값과 전체 총 빙산 값을 -1 하고, 빙산이면 queue에 추가
  - 현재 노드로부터 4방향 탐색이 끝났다면 현재 빙산 수치를 탐색한 빙산 총값을 의미하는 변수에 더한다
  - bfs 탐색을 총 빙산 수치가 0이 될 때까지 진행하며 만약 queue가 비었을 때 탐색한 빙산 값과 남은 총 빙산 수치가 다르다면 빙산이 두 덩어리 이상 존재하는 것이기 때문에 반복문을 즉시 종료
  ```
  
--------------------------------------  
### dfs

#### 1937번 : 욕심쟁이 판다 (골드3)
  * 문제 유형 : dp, graph, dfs
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 해당 위치에서 이동할 수 있는 칸 수를 의미하는 2차원 dp배열, 재귀를 활용한 dfs 탐색 사용
  - 모든 노드를 탐색하여 방문하지 않은 노드는 dfs 탐색
  - dp[i][j]에서 4방향 탐색하여 이미 방문한 노드의 경우 이동 가능 칸 수를 알고 있는 것이기 때문에 1을 더한 값이 dp[i][j]의 값보다 크면 값을 바꾸고, 방문하지 않은 노드의 경우 dfs 탐색(재귀 이용)을 한 후 1을 더한 값이 dp[i][j]의 값보다 크면 값을 바꿈
  - 4방향 탐색 후 정해진 dp[i][j]값이 이동 가능 최대 칸 수를 의미하는 max보다 크면 값을 변경
  ```
  
#### 3109번 : 빵집 (골드2)
  * 문제 유형 : greedy, graph, dfs
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 :
  ```
  - 맨 왼쪽 열의 한 노드부터 맨 오른쪽 열의 한 노드까지 서로 겹치지 않고 이어지는 경로의 최대 개수를 구하는 문제이기 때문에 dfs 사용
  - 어느 한 노드에서 바로 오른쪽 열의 노드로 갈 수 있는 경우의 수는 오른쪽 대각선 위, 오른쪽, 오른쪽 대각선 아래 3가지
  - 맨 위쪽 행부터 시작하여(stack에 넣는 순서도 반대로하면 반대여도 무관) 경로를 찾을 경우 최대한 위쪽에 치우친 경로를 만들어야 이후 경로에 영향을 끼칠 확률이 줄어들기 때문에 오른쪽 대각선 아래, 오른쪽, 오른쪽 대각선 위 순으로 stack에 add(stack은 후입선출 방식이기 때문)
  - stack에 push할때 visit을 true로 체크 할 경우 이후 다른 경로를 택 해야할 경우 사용하지 않는 노드 또한 방문한 것이 되기 때문에 stakc에서 pop한 후 다음 경로가 존재하는 경우에만 visit을 true로 체크
  - stack에서 pop한 노드의 위치가 맨 오른쪽 열일 경우 조건에 만족하는 경로가 이어진 것이기 때문에 경로 개수를 증가
  ```
