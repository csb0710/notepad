# Graphs


#### 2252번 : 줄 세우기 (골드3)
  * 문제 유형 : graph
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - Queue, 각 노드의 선행 노드 개수를 의미하는 배열, 각 노드의 후위 노드를 저장하는 ArrayList를 이용
  - 선행 노드의 개수가 0인 노드를 Queue에 넣고, 하나씩 빼내어 출력, 후위 노드들의 각 선행 노드 개수를 줄인다
  - 만약 선행 노드의 개수가 0이 되면 Queue에 집어넣으며 이 과정을 Queue가 빌 때까지 반복 (만약 출력한 노드의 수와 총 노드의 수가 다르면 사이클 존재 -> 위상정렬 개념, 이 문제에는 해당 입력 case가 존재하지 않음)
  ``` 

#### 1516번 : 게임 개발 (골드3)
  * 문제 유형 : dp
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - 기존의 위상 정렬은 동시간대에 선택되는 정점까지 따질 필요는 없었지만, 각 건물(노드)들의 최소 완성 시간을 구해야하기 때문에 선행 건물의 건설 시간 중 가장 오래 걸리는 시간을 알아야한다
  - 따라서 queue를 사용하던 위상 정렬과 달리 건설 시간을 오름차순 기준으로 정렬하는 우선순위 큐를 이용하여 위상 정렬
  - 선행 노드의 개수가 0이 되면 먼저 앞선 건물들의 건설 시간을 현재 건물의 건설 시간에 더한 후 우선순위 큐에 넣어야 정확한 각 건물별 최소 완성 시간을 구할 수 있음
  ```
  
#### 1516번 : ACM Craft (골드3)
  * 문제 유형 : dp, graph
  * 시간 복잡도 : O(case*(V+E))
  * 풀이 방식 : 
  ```
  - 우선순위 큐와 위상정렬을 이용하는 풀이법(1516번 게임 개발)을 각 case별로 적용
  ```

-------------------------------------------------
### bfs
#### 16236번 :  아기 상어 (골드3)
  * 문제 유형 : graphs, bfs, implementation, simulation
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 상어가 먹을 수 있는 물고기들을 선택할 때 가장 가까운 거리에 위치한 물고기 중 선택해야하기 때문에 bfs를 이용
  - 거리가 같은 물고기일 경우 가장 왼쪽에 위치한 물고기, 왼쪽 거리도 같다면 가작 위쪽에 위치한 물고기를 선택해야하기 때문에 이에 맞게 우선순위큐의 compare 조건을 지정
  - 거리 1당 시간이 1씩 걸리기 때문에 선택한 물고기로 이동할 때마다 떨어진 거리(물고기까지의 bfs시행 횟수)만큼 더하여 총 이동 시간을 구한다
  ```

#### 2206번 : 벽 부수고 이동하기 (골드3)*
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 시작 지점으로부터 목표 지점까지의 최소 거리를 구하는 문제이기 때문에 기존의 bfs 풀이방식을 이용
  - 벽을 1개를 부숴 길을 만들 수 있기 때문에 벽을 부수고 이동했을 때 보다 벽을 부수지 않고 이동했을 때가 더 최소값인 경우 기존의 visit배열을 사용했을 경우 탐색 불가
  - 기존의 visit 배열과는 다르게 벽을 부수지 않고 이동했을 때, 벽을 1개 부수고 이동했을 때의 visit배열을 따로 관리하기 위해 3차원 배열을 이용(visit[n][m][2])
  ```

#### 14442번 : 벽 부수고 이동하기2 (골드2)
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 2206번과 동일한 방법으로 visit 배열을 벽의 제한 갯수의 크기로 만들어 주고, 각 정점 방문시 따지는 조건 또한 갯수 제한에 따라 바꿔줌(visit[n][m][k])
  ```
  
#### 2638번 : 치즈 (골드3)
  * 문제 유형 : graph, bfs, dfs
  * 시간 복잡도 : O(t*nm)
  * 풀이 방식 : 
  ```
  - 가장자리는 항상 치즈(1)이 없기 때문에 가장자리부터 연속적으로 이어지는 치즈가 아닌 빈 블록을 활용하는 방법을 사용하기 때문에 bfs와 dfs 모두 가능
  - visit 배열뿐만이 아니라 치즈의 공기 노출면의 개수를 체크하는 check 배열을 사용
  - (0, 0)부터 bfs 탐색을 시작하여 (i, j)가 공기(0)일 경우 queue에 집어 넣고, 치즈(1)일 경우 check[i][j]가 이미 true일 때는 해당 치즈를 없애고, false일 때는 공기 노출면이 적어도 하나 존재함을 나타내기 위해 check[i][j]를 true로 바꿔준다
  - 과정 반복 중 queue가 비었을 경우 1시간이 지나 공기 접촉면이 2개 이상인 테두리 치즈들이 녹은 것을 뜻하기 때문에 while문을 하나 더 이용하여 삭제 된 치즈의 개수가 처음 입력 받은 치즈의 총 개수와 같아질 때, 즉 모든 치즈가 삭제될 때까지 반복하여 총 시간을 구한다
  ```
  
#### 2573번 : 빙산 (골드4)
  * 문제 유형 : implementation, graph, dfs, bfs
  * 시간 복잡도 : O(t*nm)
  * 풀이 방식 :
  ```
  - 2중 for문을 이용하여 빙산 노드를 탐색
  - 탐색한 빙산 노드부터 시작하여 bfs 탐색을 시작
  - 현재 노드의 주변 노드가 바다면 노드의 값과 전체 총 빙산 값을 -1 하고, 빙산이면 queue에 추가
  - 현재 노드로부터 4방향 탐색이 끝났다면 현재 빙산 수치를 탐색한 빙산 총값을 의미하는 변수에 더한다
  - bfs 탐색을 총 빙산 수치가 0이 될 때까지 진행하며 만약 queue가 비었을 때 탐색한 빙산 값과 남은 총 빙산 수치가 다르다면 빙산이 두 덩어리 이상 존재하는 것이기 때문에 반복문을 즉시 종료
  ```
  
--------------------------------------  
### dfs

#### 1937번 : 욕심쟁이 판다 (골드3)
  * 문제 유형 : dp, graph, dfs
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 해당 위치에서 이동할 수 있는 칸 수를 의미하는 2차원 dp배열, 재귀를 활용한 dfs 탐색 사용
  - 모든 노드를 탐색하여 방문하지 않은 노드는 dfs 탐색
  - dp[i][j]에서 4방향 탐색하여 이미 방문한 노드의 경우 이동 가능 칸 수를 알고 있는 것이기 때문에 1을 더한 값이 dp[i][j]의 값보다 크면 값을 바꾸고, 방문하지 않은 노드의 경우 dfs 탐색(재귀 이용)을 한 후 1을 더한 값이 dp[i][j]의 값보다 크면 값을 바꿈
  - 4방향 탐색 후 정해진 dp[i][j]값이 이동 가능 최대 칸 수를 의미하는 max보다 크면 값을 변경
  ```
  
#### 3109번 : 빵집 (골드2)
  * 문제 유형 : greedy, graph, dfs
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 :
  ```
  - 맨 왼쪽 열의 한 노드부터 맨 오른쪽 열의 한 노드까지 서로 겹치지 않고 이어지는 경로의 최대 개수를 구하는 문제이기 때문에 dfs 사용
  - 어느 한 노드에서 바로 오른쪽 열의 노드로 갈 수 있는 경우의 수는 오른쪽 대각선 위, 오른쪽, 오른쪽 대각선 아래 3가지
  - 맨 위쪽 행부터 시작하여(stack에 넣는 순서도 반대로하면 반대여도 무관) 경로를 찾을 경우 최대한 위쪽에 치우친 경로를 만들어야 이후 경로에 영향을 끼칠 확률이 줄어들기 때문에 오른쪽 대각선 아래, 오른쪽, 오른쪽 대각선 위 순으로 stack에 add(stack은 후입선출 방식이기 때문)
  - stack에 push할때 visit을 true로 체크 할 경우 이후 다른 경로를 택 해야할 경우 사용하지 않는 노드 또한 방문한 것이 되기 때문에 stakc에서 pop한 후 다음 경로가 존재하는 경우에만 visit을 true로 체크
  - stack에서 pop한 노드의 위치가 맨 오른쪽 열일 경우 조건에 만족하는 경로가 이어진 것이기 때문에 경로 개수를 증가
  ```
