# Graphs

## bfs
#### 16236번 :  아기 상어 (골드3)
  * 문제 유형 : graphs, bfs, implementation, simulation
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 상어가 먹을 수 있는 물고기들을 선택할 때 가장 가까운 거리에 위치한 물고기 중 선택해야하기 때문에 bfs를 이용
  - 거리가 같은 물고기일 경우 가장 왼쪽에 위치한 물고기, 왼쪽 거리도 같다면 가작 위쪽에 위치한 물고기를 선택해야하기 때문에 이에 맞게 우선순위큐의 compare 조건을 지정
  - 거리 1당 시간이 1씩 걸리기 때문에 선택한 물고기로 이동할 때마다 떨어진 거리(물고기까지의 bfs시행 횟수)만큼 더하여 총 이동 시간을 구한다
  ```

#### 2206번 : 벽 부수고 이동하기 (골드3)*
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 시작 지점으로부터 목표 지점까지의 최소 거리를 구하는 문제이기 때문에 기존의 bfs 풀이방식을 이용
  - 벽을 1개를 부숴 길을 만들 수 있기 때문에 벽을 부수고 이동했을 때 보다 벽을 부수지 않고 이동했을 때가 더 최소값인 경우 기존의 visit배열을 사용했을 경우 탐색 불가
  - 기존의 visit 배열과는 다르게 벽을 부수지 않고 이동했을 때, 벽을 1개 부수고 이동했을 때의 visit배열을 따로 관리하기 위해 3차원 배열을 이용(visit[n][m][2])
  ```

#### 14442번 : 벽 부수고 이동하기2 (골드2)
  * 문제 유형 : graph, bfs
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 2206번과 동일한 방법으로 visit 배열을 벽의 제한 갯수의 크기로 만들어 주고, 각 정점 방문시 따지는 조건 또한 갯수 제한에 따라 바꿔줌(visit[n][m][k])
  ```
  
#### 2638번 : 치즈 (골드3)
  * 문제 유형 : graph, bfs, dfs
  * 시간 복잡도 : O(t*nm)
  * 풀이 방식 : 
  ```
  - 가장자리는 항상 치즈(1)이 없기 때문에 가장자리부터 연속적으로 이어지는 치즈가 아닌 빈 블록을 활용하는 방법을 사용하기 때문에 bfs와 dfs 모두 가능
  - visit 배열뿐만이 아니라 치즈의 공기 노출면의 개수를 체크하는 check 배열을 사용
  - (0, 0)부터 bfs 탐색을 시작하여 (i, j)가 공기(0)일 경우 queue에 집어 넣고, 치즈(1)일 경우 check[i][j]가 이미 true일 때는 해당 치즈를 없애고, false일 때는 공기 노출면이 적어도 하나 존재함을 나타내기 위해 check[i][j]를 true로 바꿔준다
  - 과정 반복 중 queue가 비었을 경우 1시간이 지나 공기 접촉면이 2개 이상인 테두리 치즈들이 녹은 것을 뜻하기 때문에 while문을 하나 더 이용하여 삭제 된 치즈의 개수가 처음 입력 받은 치즈의 총 개수와 같아질 때, 즉 모든 치즈가 삭제될 때까지 반복하여 총 시간을 구한다
  ```
