# Dynamic Programming

#### 15681번 :  트리와 쿼리 (골드5)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 리프노드부터 루트 노드로 올라오며 각 서브트리별 정점의 갯수를 dp배열에 저장
  ```

#### 1949번 :  우수 마을 (골드2)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 현재 노드를 선택했을 때의 경우와 선택하지 않았을 경우의 주민수를 저장하는 2차원 dp[n][2]를 이용
  - 현재 노드를 선택한 경우 -> 자식노드는 무조건 선택하지 않음
  - 현재 노드를 선택하지 않은 경우 -> 자식노드를 선택했을 경우와 자식노드를 선택하지 않았을 두 경우 중 더 큰 값 선택
  - 리프노드부터 루트노드(1)로 올라오며 각 경우의 주민수를 구한 후 루트노드에서 더 큰 경우를 채택하여 출력
  ```

#### 9251번 :  LCS (골드5)*
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 두 문자열의 위치를 나타내는 2차원 int 배열 dp 선언(0으로 초기화, 인덱스는 i, j로 표현)
  - 각 문자열의 현재 문자가 같을 경우 dp[i][j] = dp[i-1][j-1]
  - 다를 경우 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  - dp의 마지막 값이 LCS의 길이를 뜻함
  ```
  
#### 9252번 :  LCS2 (골드4)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식으로 dp 배열을 구하고 마지막 값부터 시작하여 dp[i-1][j]와 dp[i][j-1] 중 dp[i][j]가 같은 값이 존재할 경우 해당 위치로 이동
  - 같은 값이 없을 경우 해당 위치의 문자를 Stack에 추가 후 dp[i-1][j-1]로 이동 -> 해당 dp의 위치가 두 문자열에서 현재 문자를 찾은 순간이기 때문에 현재 문자를 stack에 추가하고 현재 문자 전 위치의 dp로 이동
  ```
  
#### 9252번 :  LCS3 (골드3)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nmk)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식이지만 비교 문장이 3개이기 때문에 dp배열을 3차원 배열로 이용(dp[n][m][k])
  - 다를 경우 dp[i][j] = Math.max(Math.max(dp[i-1][j][k], dp[i][j-1][k]), dp[i][j][k-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  ```
  
#### 11053번 : 가장 긴 증가하는 부분 수열 (실버2)*
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 일차원 dp배열을 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  ```

#### 14002번 : 가장 긴 증가하는 부분 수열4 (골드4)
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 일차원 dp배열을 이용
  - 부분 수열의 각 값에 선행 값을 저장하는 prev배열 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장하고, prev 배열에 선행 값 저장
  - 선행 값을 따라가다보면 역순으로 나열되기 때문에 stack에 저장후 값을 모두 빼내어 출력
  ```

#### 11054번 : 가장 긴 바이토닉 부분 수열 (골드3)
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 가장 긴 증가하는 부분 수열과 가장 긴 감소하는 부분 수열을 저장하는 일차원 dp배열 두 개를 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  - 수열의 현재 값 보다 앞선 큰 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  - 두 dp배열의 값을 각 인덱스마다 더한 후 가장 큰 값이 가장 긴 바이토닉 부분 수열
  ```

#### 11054번 : 줄 세우기 (골드4)*
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 증가하는 순서로 서있는 애들을 제외한 나머지 어린이의 위치를 옮기면 최소 횟수로 줄을 세울 수 있기 때문에 가장 긴 증가하는 부분 수열(LCS)를 이용
  - LCS를 구해서 총 어린이 수에서 빼면 위치를 옮겨야되는 최소 어린이 수를 구할 수 있다
  ```
