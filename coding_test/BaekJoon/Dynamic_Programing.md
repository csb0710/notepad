# Dynamic Programming

#### 15681번 :  트리와 쿼리 (골드5)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 리프노드부터 루트 노드로 올라오며 각 서브트리별 정점의 갯수를 dp배열에 저장
  ```

#### 1949번 :  우수 마을 (골드2)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 현재 노드를 선택했을 때의 경우와 선택하지 않았을 경우의 주민수를 저장하는 2차원 dp[n][2]를 이용
  - 현재 노드를 선택한 경우 -> 자식노드는 무조건 선택하지 않음
  - 현재 노드를 선택하지 않은 경우 -> 자식노드를 선택했을 경우와 자식노드를 선택하지 않았을 두 경우 중 더 큰 값 선택
  - 리프노드부터 루트노드(1)로 올라오며 각 경우의 주민수를 구한 후 루트노드에서 더 큰 경우를 채택하여 출력
  ```

#### 9251번 :  LCS (골드5)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 두 문자열의 위치를 나타내는 2차원 int 배열 dp 선언(0으로 초기화, 인덱스는 i, j로 표현)
  - 각 문자열의 현재 문자가 같을 경우 dp[i][j] = dp[i-1][j-1]
  - 다를 경우 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  - dp의 마지막 값이 LCS의 길이를 뜻함
  ```
  
#### 9252번 :  LCS2 (골드4)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식으로 dp 배열을 구하고 마지막 값부터 시작하여 dp[i-1][j]와 dp[i][j-1] 중 dp[i][j]가 같은 값이 존재할 경우 해당 위치로 이동
  - 같은 값이 없을 경우 해당 위치의 문자를 Stack에 추가 후 dp[i-1][j-1]로 이동 -> 해당 dp의 위치가 두 문자열에서 현재 문자를 찾은 순간이기 때문에 현재 문자를 stack에 추가하고 현재 문자 전 위치의 dp로 이동
  ```
  
#### 9252번 :  LCS3 (골드3)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nmk)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식이지만 비교 문장이 3개이기 때문에 dp배열을 3차원 배열로 이용(dp[n][m][k])
  - 다를 경우 dp[i][j] = Math.max(Math.max(dp[i-1][j][k], dp[i][j-1][k]), dp[i][j][k-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  ```
