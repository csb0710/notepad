# Dynamic Programming

#### 15681번 : 트리와 쿼리 (골드5)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 리프노드부터 루트 노드로 올라오며 각 서브트리별 정점의 갯수를 dp배열에 저장
  ```

#### 1949번 : 우수 마을 (골드2)
  * 문제 유형 : dp, tree
  * 시간 복잡도 : O(n)
  * 풀이 방식 : 
  ```
  - ArrayList를 이용해서 트리를 저장
  - 방문한 정점 체크용 visit배열 이용
  - 현재 노드를 선택했을 때의 경우와 선택하지 않았을 경우의 주민수를 저장하는 2차원 dp[n][2]를 이용
  - 현재 노드를 선택한 경우 -> 자식노드는 무조건 선택하지 않음
  - 현재 노드를 선택하지 않은 경우 -> 자식노드를 선택했을 경우와 자식노드를 선택하지 않았을 두 경우 중 더 큰 값 선택
  - 리프노드부터 루트노드(1)로 올라오며 각 경우의 주민수를 구한 후 루트노드에서 더 큰 경우를 채택하여 출력
  ```

#### 9251번 : LCS (골드5)*
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 두 문자열의 위치를 나타내는 2차원 int 배열 dp 선언(0으로 초기화, 인덱스는 i, j로 표현)
  - 각 문자열의 현재 문자가 같을 경우 dp[i][j] = dp[i-1][j-1]
  - 다를 경우 dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  - dp의 마지막 값이 LCS의 길이를 뜻함
  ```
  
#### 9252번 : LCS2 (골드4)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nm)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식으로 dp 배열을 구하고 마지막 값부터 시작하여 dp[i-1][j]와 dp[i][j-1] 중 dp[i][j]가 같은 값이 존재할 경우 해당 위치로 이동
  - 같은 값이 없을 경우 해당 위치의 문자를 Stack에 추가 후 dp[i-1][j-1]로 이동 -> 해당 dp의 위치가 두 문자열에서 현재 문자를 찾은 순간이기 때문에 현재 문자를 stack에 추가하고 현재 문자 전 위치의 dp로 이동
  ```
  
#### 9252번 : LCS3 (골드3)
  * 문제 유형 : dp, String
  * 시간 복잡도 : O(nmk)
  * 풀이 방식 : 
  ```
  - 9251번과 같은 방식이지만 비교 문장이 3개이기 때문에 dp배열을 3차원 배열로 이용(dp[n][m][k])
  - 다를 경우 dp[i][j] = Math.max(Math.max(dp[i-1][j][k], dp[i][j-1][k]), dp[i][j][k-1]) -> 현재까지 구한 LCS의 길이를 뜻함
  ```
  
#### 11053번 : 가장 긴 증가하는 부분 수열 (실버2)*
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 일차원 dp배열을 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  ```

#### 14002번 : 가장 긴 증가하는 부분 수열4 (골드4)
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 일차원 dp배열을 이용
  - 부분 수열의 각 값에 선행 값을 저장하는 prev배열 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장하고, prev 배열에 선행 값 저장
  - 선행 값을 따라가다보면 역순으로 나열되기 때문에 stack에 저장후 값을 모두 빼내어 출력
  ```

#### 11054번 : 가장 긴 바이토닉 부분 수열 (골드3)
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 가장 긴 증가하는 부분 수열과 가장 긴 감소하는 부분 수열을 저장하는 일차원 dp배열 두 개를 이용
  - 수열의 현재 값 보다 앞선 작은 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  - 수열의 현재 값 보다 앞선 큰 값 중 dp에 저장되어있는 부분 수열의 크기가 가장 큰 수열의 크기 택해 1 증가된 값을 dp의 현재 값에 저장
  - 두 dp배열의 값을 각 인덱스마다 더한 후 가장 큰 값이 가장 긴 바이토닉 부분 수열
  ```

#### 11054번 : 줄 세우기 (골드4)*
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 증가하는 순서로 서있는 애들을 제외한 나머지 어린이의 위치를 옮기면 최소 횟수로 줄을 세울 수 있기 때문에 가장 긴 증가하는 부분 수열(LCS)를 이용
  - LCS를 구해서 총 어린이 수에서 빼면 위치를 옮겨야되는 최소 어린이 수를 구할 수 있다
  ```
  
#### 1516번 : 게임 개발 (골드3)
  * 문제 유형 : dp
  * 시간 복잡도 : O(V+E)
  * 풀이 방식 : 
  ```
  - 기존의 위상 정렬은 동시간대에 선택되는 정점까지 따질 필요는 없었지만, 각 건물(노드)들의 최소 완성 시간을 구해야하기 때문에 선행 건물의 건설 시간 중 가장 오래 걸리는 시간을 알아야한다
  - 따라서 queue를 사용하던 위상 정렬과 달리 건설 시간을 오름차순 기준으로 정렬하는 우선순위 큐를 이용하여 위상 정렬
  ```
  
#### 10942번 : 팰린드롬? (골드4)
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 2차원 dp 배열을 이용하며 dp[i][j]는 문자열 i부터 j까지 펠린드롬인지 아닌지를 나타냄
  - dp[i][j]에서 dp[i+1][j-1](대각선 왼쪽아래방향)은 문자열 i+1부터 j-1까지 펠린드롬 판정을 의미하기 때문에 i번째 문자와 j번째 문자가 같고, dp[i+1][j-1]이 펠린드롬(1)일 경우 i부터 j까지 문자열도 펠린드롬이기 때문에 점화식을 짤 수 있음
  - 단 인접한 두 개의 문자끼리 비교할 때는 dp[i+][j-1]의 값이 존재하지 않고, 두 문자만 같으면 무조건 펠린드롬이기 때문에 따로 
  ```

#### 2293번 : 동전 1 (골드5)*
  * 문제 유형 : dp
  * 시간 복잡도 : O(n^2)
  * 풀이 방식 : 
  ```
  - 메모리 제한이 4mb 밖에 되지 않기 때문에 일차원 dp배열을 사용해야 함
  - 동전들의 조합으로 돈의 액수를 맞출 수 있는 경우의 수를 따져야하기 때문에 작은 단위로만 가능한 경우 + 현재 단위와 더 작은 단위의 조합으로 가능한 경우를 구해줘야 함 (dp[i] = dp[i] + dp[i-coin])
  - 단위가 작은 동전부터 dp를 덧붙여 채워넣으면서 가장 큰 단위의 동전까지 완료한 후 dp[k]에 있는 값이 정답
  ```
